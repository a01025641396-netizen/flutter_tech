# Riverpod 상태 관리 패턴의 특징
# 1. 컴파일 타임 안전성 (Compile-time Safety)
# Riverpod의 가장 큰 특징은 Provider와 달리 컴파일 시점에 오류를 발견할 수 있다는 점입니다. 

# 2. 위젯 트리로부터의 독립성
# 상태가 위젯 트리에 종속되지 않습니다. 상태를 선언할 때 위젯 트리 외부(전역)에 정의하기 때문에, 위젯의 계층 구조와 상관없이 어디서든 자유롭게 상태에 접근할 수 있습니다. 이는 비즈니스 로직과 UI 로직을 완전히 분리하는 데 매우 유리한 구조를 제공합니다.

# 3. 유연하고 다양한 프로바이더 (Provider Variants)
# 상태의 성격에 따라 최적화된 다양한 프로바이더를 제공하여 개발 효율을 높입니다.

# Provider: 불변 데이터나 계산된 값을 제공할 때 사용 (읽기 전용)

# StateProvider: 간단한 단일 변수 상태를 관리할 때 적합

# NotifierProvider: 복잡한 비즈니스 로직과 상태 변경 메서드가 필요할 때 사용 (가장 권장됨)

# FutureProvider: API 통신 등 비동기 작업의 결과값을 관리할 때 필수적

# StreamProvider: 실시간 데이터 스트림을 처리할 때 사용

# 4. 선언적 가독성 및 효율적인 상태 제어
# 상태 관리를 위해 직관적이고 강력한 메서드를 제공합니다.

# .watch(웨치): 상태 변화를 실시간으로 감시하며 변화가 생기면 위젯을 자동으로 재빌드합니다.

# .read(리드): 상태 변화를 감시하지 않고 단발성으로 값을 읽어올 때 사용합니다 (예: 버튼 클릭 이벤트).

# .select(솔렉션): 상태의 특정 부분만 골라 감시하여, 관련 없는 데이터 변경 시 발생하는 불필요한 재빌드를 방지합니다.

# 5. 자동 리소스 관리 
# 더 이상 사용되지 않는 상태를 자동으로 메모리에서 해제할 수 있습니다. 예를 들어 특정 페이지를 벗어날 때 사용하던 데이터를 즉시 삭제하여 메모리 누수를 방지하고 최적화된 환경을 유지합니다.

# 6. 테스트 및 디버깅의 용이성
# 상태가 전역에 정의되어 있음에도 불구하고, 테스트 코드 작성 시 Mock(마크) 데이터로 교체가 매우 간편합니다. 또한 Riverpod Observer(리버팟 업소볼)를 통해 모든 상태 변화를 전역적으로 모니터링하고 로깅할 수 있어 디버깅 효율이 뛰어납니다.