1. 메모리 할당 위치
가장 큰 기술적 차이는 데이터가 저장되는 메모리 영역입니다.

값 형식: 일반적으로 스택(Stack) 메모리에 할당됩니다. 변수가 선언된 블록을 벗어나면 메모리에서 즉시 제거되므로 속도가 매우 빠릅니다.

참조 형식: 실제 데이터는 힙(Heap) 메모리에 저장되며, 스택에는 데이터가 위치한 힙의 **메모리 주소(참조)**가 저장됩니다. 힙에 할당된 메모리는 가비지 컬렉터(Garbage Collector)에 의해 관리됩니다.

2. 데이터 복사 방식
변수를 다른 변수에 할당할 때 발생하는 동작이 다릅니다.

값 형식 (Deep Copy)
변수 할당 시 데이터 값이 그대로 복사됩니다. 따라서 복사본의 값을 변경해도 원본 변수에는 아무런 영향을 주지 않습니다.

해당 타입: int, float, bool, char, struct, enum 등

참조 형식 (Shallow Copy)
변수 할당 시 데이터 자체가 아닌 **메모리 주소(참조)**가 복사됩니다. 즉, 두 변수가 동일한 객체를 가리키게 되므로, 한쪽에서 데이터를 수정하면 다른 쪽에서도 변경된 내용을 보게 됩니다.

해당 타입: class, interface, delegate, string, array 등

3. 주요 특성 비교
구분	값 형식 (Value Type)	참조 형식 (Reference Type)
저장 위치	스택 (Stack)	힙 (Heap)
할당 방식	실제 값 저장	값이 위치한 주소 저장
복사 효과	독립적인 복사본 생성	동일한 객체 공유
기본값	0, false 등 데이터 타입별 초기값	null
성능	관리가 빠르나 큰 데이터 복사 시 부담	가비지 컬렉션(GC) 비용 발생
4. 구조체(Struct)와 클래스(Class)의 선택 기준
값 형식인 구조체와 참조 형식인 클래스를 선택할 때는 데이터의 크기와 수명을 고려해야 합니다.

구조체(Value Type) 권장:

데이터 크기가 작고(약 16바이트 미만) 단순한 경우.

인스턴스의 수명이 짧은 경우.

불변(Immutable) 데이터를 표현할 때.

클래스(Reference Type) 권장:

데이터 크기가 크거나 논리적으로 복잡한 경우.

객체의 정체성(Identity)을 유지하며 여러 곳에서 공유해야 할 경우.

상속(Inheritance) 등의 객체 지향 기능이 필요한 경우.

값 형식과 참조 형식의 차이를 이해하는 것은 메모리 효율성과 버그 방지 측면에서 매우 중요합니다. 혹시 구조체와 클래스의 성능 차이에 대해 구체적인 코드 예시와 함께 더 자세히 알고 싶으신가요?
