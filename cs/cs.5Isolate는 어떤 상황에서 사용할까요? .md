
1. Isolate(아이솔레이드)를 사용하는 상황
Isolate는 메인 UI 쓰레드의 차단(Blocking)을 방지해야 할 때 사용합니다. Dart는 기본적으로 싱글 쓰레드로 동작하므로, 무거운 작업이 메인 Isolate에서 실행되면 프레임 드랍(Jank)이 발생합니다.

대규모 데이터 파싱: 거대한 JSON 파일을 객체로 변환하거나 복잡한 XML을 처리할 때.

복잡한 계산 작업: 암호화/복사 알고리즘, 대량의 숫자 계산, 이미지 필터 적용 및 리사이징.

파일 및 데이터베이스 작업: 매우 큰 파일을 읽고 쓰거나, 복잡한 로컬 DB 쿼리를 수행할 때.

네트워크 스트림 처리: 지속적으로 들어오는 대량의 패킷 데이터를 실시간으로 가공해야 할 때.

2. Isolate의 특징과 연결한 사용 시 주의사항
Isolate는 이름 그대로 **'격리(Isolate)'**되어 있다는 점이 모든 제약 사항의 원인이 됩니다.

① 메모리 비공유 (No Shared Memory)
특징: Isolate 간에는 메모리를 공유할 수 없습니다. 데이터를 전달할 때는 복사(Copy) 방식이나 객체 소유권 이전(Send-and-Exit) 방식을 사용합니다.

주의점: 전역 변수나 정적(static) 변수에 접근하더라도 각 Isolate는 자신만의 복사본을 가집니다. 즉, A Isolate에서 변경한 전역 변수 값이 B Isolate에는 반영되지 않습니다.

② 메시지 패싱 (Message Passing)
특징: ReceivePort와 SendPort를 통해서만 소통할 수 있습니다.

주의점: 데이터를 주고받을 때 내부적으로 직렬화(Serialization) 과정이 발생할 수 있습니다. 매우 큰 데이터를 빈번하게 주고받으면 오히려 통신 비용 때문에 성능이 저하될 수 있으므로, 결과값만 정제해서 전달하는 것이 효율적입니다.

③ UI 접근 불가 (No UI Access)
특징: 메인 Isolate만이 Flutter의 UI 프레임워크와 연결되어 있습니다.

주의점: 별도의 Isolate 내에서는 BuildContext를 사용하거나 UI 위젯을 직접 조작할 수 없습니다. 모든 결과는 다시 메인 Isolate로 보내어 setState() 등을 통해 반영해야 합니다.

④ 오버헤드 (Creation Overhead)
특징: 새로운 Isolate를 생성하는 것은 별도의 메모리 공간과 루프를 설정하는 무거운 작업입니다.

주의점: 아주 짧은 연산을 위해 Isolate를 만드는 것은 배보다 배꼽이 더 큰 결과를 초래합니다. 수 밀리초(ms) 이내에 끝나는 작업은 Future를 이용한 비동기 처리로 충분합니다.