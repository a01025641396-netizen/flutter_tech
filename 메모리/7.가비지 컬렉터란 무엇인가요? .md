**가비지 컬렉터(Garbage Collector, GC)**는 프로그램이 동적으로 할당했던 메모리 영역(Heap) 중에서 더 이상 사용되지 않는 객체를 자동으로 찾아내어 메모리에서 해제해 주는 메모리 관리 관리자입니다.

과거 C/C++ 같은 언어에서는 개발자가 malloc()으로 메모리를 빌리고 free()로 직접 반납해야 했지만, 현대적인 언어(Java, Dart, Python, JavaScript 등)는 GC가 이 번거롭고 위험한 작업을 대신 수행합니다.

1. 가비지 컬렉터의 핵심 원리: 도달 가능성 (Reachability)
GC는 어떤 객체가 '쓰레기(Garbage)'인지 판단하기 위해 도달 가능성이라는 개념을 사용합니다.

Reachable: 루트(Root) 세트(스택의 지역 변수, 전역 변수 등)로부터 참조 사슬을 통해 연결된 객체입니다. "누군가 사용 중"이므로 유지합니다.

Unreachable: 어떤 경로로도 참조되지 않는 객체입니다. "더 이상 접근할 방법이 없음"으로 판단하여 가비지로 분류하고 삭제합니다.

2. 가비지 컬렉션의 주요 알고리즘
Mark and Sweep: * Mark: 사용 중인 객체를 모두 찾아 표시합니다.

Sweep: 표시되지 않은(가비지) 객체들을 메모리에서 지웁니다.

Copying: 메모리를 두 영역으로 나눠, 사용 중인 객체만 새 영역으로 복사하고 기존 영역을 통째로 비웁니다.

Generational GC (세대별 수집):

"대부분의 객체는 금방 사라진다"는 가설(Weak Generational Hypothesis)에 기반합니다.

새로 생성된 객체(Young Generation)를 자주 검사하고, 오래 살아남은 객체(Old Generation)는 가끔 검사하여 효율을 높입니다.

3. 가비지 컬렉터의 단점: Stop-the-world
GC가 메모리를 청소하는 동안에는 프로그램의 실행이 일시적으로 중단됩니다. 이를 Stop-the-world라고 합니다.

GC 작업이 너무 길어지면 사용자 화면이 뚝뚝 끊기는(Jank) 현상이 발생할 수 있습니다.

따라서 현대의 GC는 이 중단 시간을 최소화하기 위해 병렬 처리나 백그라운드 처리를 수행하도록 발전하고 있습니다.