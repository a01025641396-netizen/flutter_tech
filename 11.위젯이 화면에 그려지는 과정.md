플러터(Flutter)에서 위젯이 실제 화면에 픽셀로 나타나기까지의 과정은 크게 3가지 트리 구조와 렌더링 파이프라인을 거쳐 수행됩니다. 이 과정은 효율적인 UI 업데이트와 고성능 그래픽 출력을 위해 설계되었습니다.

1. 세 가지 트리 (The Three Trees)
플러터는 성능 최적화를 위해 UI를 세 단계의 계층 구조로 관리합니다.

Widget Tree (설계도): 개발자가 작성한 코드로, UI의 구성과 설정을 정의합니다. 불변(Immutable) 상태이며 매우 가볍습니다.

Element Tree (중재자): 위젯과 실제 렌더링 객체를 연결합니다. 위젯의 위치와 상태(State)를 유지하며, 위젯이 변경될 때 어떤 부분을 업데이트할지 결정합니다.

RenderObject Tree (실제 구현체): 화면의 크기, 위치를 계산(Layout)하고 그리는(Paint) 역할을 수행하는 무거운 객체들입니다.

2. 렌더링 파이프라인 (The Rendering Pipeline)
위젯 트리에서 변경사항이 발생하면, 다음의 5단계를 거쳐 화면이 갱신됩니다.

① Build (빌드 단계)
상태가 변경되어 setState() 등이 호출되면 위젯 트리가 다시 생성됩니다. 이때 Element Tree는 새로운 위젯과 기존 위젯을 비교하여, 변경된 부분만 찾아서 RenderObject Tree에 업데이트를 요청합니다.

② Layout (레이아웃 단계)
화면 내 객체들의 크기와 위치를 결정합니다. 플러터의 레이아웃은 다음의 원칙을 따릅니다.

Constraints go down: 부모가 자식에게 허용 가능한 최소/최대 크기(제약 조건)를 전달합니다.

Sizes go up: 자식은 전달받은 제약 조건 내에서 자신의 크기를 결정하여 부모에게 보고합니다.

③ Paint (페인트 단계)
레이아웃이 완료되면 각 위젯이 어떻게 보일지 결정합니다. 이때 실제 픽셀을 그리는 것이 아니라, 화면을 어떻게 그려야 할지에 대한 그리기 명령(Painting Commands) 리스트를 생성합니다.

④ Composition (합성 단계)
복잡한 UI의 경우 레이어(Layer)를 나누어 관리합니다. 이 단계에서는 나누어진 레이어들을 하나로 합치는 작업을 수행하며, 이는 GPU에서 효율적으로 처리될 수 있도록 준비하는 과정입니다.

⑤ Rasterizing (래스터화 단계)
마지막으로 렌더링 엔진(Skia 또는 Impeller)이 위 단계에서 생성된 명령과 레이어 정보를 바탕으로 물리적인 픽셀로 변환하여 화면에 출력합니다.