1. S: 단일 책임 원칙 (Single Responsibility Principle, SRP)
정의: 클래스는 오직 **하나의 책임(기능)**만을 가져야 하며, 클래스를 변경해야 하는 이유는 단 하나여야 합니다.

비유: 요리사가 요리도 하고, 서빙도 하고, 계산도 하고, 청소까지 다 하면 한 분야가 바뀔 때마다 전체 업무가 꼬입니다. 각각의 역할을 분리하는 것과 같습니다.

장점: 코드가 단순해지고, 수정 시 다른 기능에 미치는 영향이 적습니다.

2. O: 개방-폐쇄 원칙 (Open-Closed Principle, OCP)
정의: 소프트웨어 요소는 확장에는 열려 있어야 하고, 수정에는 닫혀 있어야 합니다.

설명: 기존의 코드를 변경하지 않으면서 새로운 기능을 추가할 수 있도록 설계해야 합니다. 이는 주로 추상화와 상속을 통해 이루어집니다.

비유: 스마트폰에 새로운 앱을 설치(확장)한다고 해서 스마트폰의 운영체제(기존 코드)를 뜯어고칠 필요가 없는 것과 같습니다.

3. L: 리스코프 치환 원칙 (Liskov Substitution Principle, LSP)
정의: 자식 클래스는 언제나 자신의 부모 클래스를 대체할 수 있어야 합니다.

설명: 부모 클래스 자리에 자식 클래스를 넣어도 프로그램이 의도대로 동작해야 한다는 원칙입니다. 상속의 관계가 논리적으로 올바라야 함을 강조합니다.

비유: '탈것'이라는 부모 아래 '자동차'와 '자전거'가 있다면, 탈것이 필요한 자리에 자동차를 넣어도 이동이라는 기능에 문제가 없어야 합니다.

4. I: 인터페이스 분리 원칙 (Interface Segregation Principle, ISP)
정의: 사용하지 않는 메서드에 의존하도록 강제해서는 안 됩니다.

설명: 하나의 거대한 인터페이스보다는, 여러 개의 구체적인 인터페이스로 잘게 쪼개는 것이 좋습니다.

비유: 다기능 리모컨 하나에 모든 버튼을 다 넣기보다, TV용 리모컨과 에어컨용 리모컨을 따로 두어 필요한 기능만 쓰게 하는 것과 같습니다.

5. D: 의존 역전 원칙 (Dependency Inversion Principle, DIP)
정의: 고수준 모듈은 저수준 모듈에 의존해서는 안 되며, 둘 다 추상화에 의존해야 합니다.

설명: 구체적인 클래스(구현체)보다는 인터페이스나 추상 클래스에 의존하라는 의미입니다. 변화하기 쉬운 것에 의존하지 말고, 변하지 않는 기준에 의존하라는 뜻입니다.

비유: 전등 스위치를 벽에 직접 연결(고정)하지 않고, 표준 플러그(추상화)를 사용하여 어떤 전동 기구든 갈아 끼울 수 있게 만드는 설계입니다.